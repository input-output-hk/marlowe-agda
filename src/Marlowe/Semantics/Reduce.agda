module Marlowe.Semantics.Reduce where

open import Agda.Builtin.Int using (Int)
open import Data.Bool using (Bool; if_then_else_; not; _‚àß_; _‚à®_; true; false)
open import Data.Bool.Properties using (_‚âü_; ¬¨-not)
open import Data.Integer as ‚Ñ§ using (0‚Ñ§; _‚â§_; _>_; ‚à£_‚à£; _<?_; _‚â§?_)
open import Data.Integer.Properties as ‚Ñ§ using ()
open import Data.List using (List; []; _‚à∑_; _++_; foldr; reverse; [_]; null; sum; filter; map)
open import Data.List.Membership.Propositional using () renaming (_‚àà_ to _‚àà-List_)
open import Data.List.Relation.Unary.Any using (Any; lookup; _‚îÄ_; _‚à∑=_; here; there)
open import Data.List.Relation.Unary.All.Properties using (¬¨Any‚áíAll¬¨; All¬¨‚áí¬¨Any)
open import Data.Maybe using (Maybe; just; nothing; fromMaybe)
open import Data.Nat as ‚Ñï using (‚Ñï; zero; suc; s‚â§s; _‚äì_; _‚à∏_; _+_; _<·µá_; _‚â§·µá_)
open import Data.Nat.Properties using (1+n‚â∞n; ‚â§-trans; +-identity ≥; +-comm; +-assoc; ‚â§‚áí‚âØ; m‚â§m+n; ‚â∞‚áí>; ‚âÆ‚áí‚â•)
open import Data.Product using (Œ£; _,_; ‚àÉ; Œ£-syntax; ‚àÉ-syntax)
open import Data.Product using (_√ó_; proj‚ÇÅ; proj‚ÇÇ)
import Data.String as String
open import Function.Base using (case_of_; _‚àò_)

open import Relation.Nullary.Decidable using (‚åä_‚åã)
open import Relation.Nullary using (Dec; yes; no; ¬¨_)

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_‚â°_; refl; cong; sym)
open import Data.Empty using (‚ä•; ‚ä•-elim)

open import Marlowe.Language.Contract
open import Marlowe.Language.Input
open import Marlowe.Language.State
open import Marlowe.Language.Transaction
open import Marlowe.Semantics.Evaluate

open import Contrib.Data.List.AssocList
open Decidable _‚âü-AccountId√óToken_ renaming (_‚Üë_ to _‚Üë-AccountId√óToken_; _‚àà?_ to _‚àà?-AccountId√óToken_)
open Decidable _‚âü-ChoiceId_ renaming (_‚Äº_default_ to _‚Äº-ChoiceId_default_) using (_‚àà?_)
open Decidable _‚âü-ValueId_ renaming (_‚Äº_ to _‚Äº-ValueId_; _‚Äº_default_ to _‚Äº-ValueId_default_; _‚àà?_ to _‚àà-ValueId?_) hiding (_‚Üë_)

open Environment using (timeInterval)
open State using (accounts; boundValues; choices)
open TimeInterval using (startTime)

data ReduceWarning : Set where
  ReduceNonPositivePay : AccountId ‚Üí Payee ‚Üí Token ‚Üí Int ‚Üí ReduceWarning
  ReducePartialPay : AccountId ‚Üí Payee ‚Üí Token ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ReduceWarning
  ReduceShadowing : ValueId ‚Üí Int ‚Üí Int ‚Üí ReduceWarning
  ReduceAssertionFailed : ReduceWarning

record Configuration : Set where
  field contract : Contract
        state : State
        environment : Environment
        warnings : List ReduceWarning
        payments : List Payment

open Configuration

data _‚áÄ_ : Configuration ‚Üí Configuration ‚Üí Set where

  CloseRefund :
    ‚àÄ { a : AccountId }
      { t : Token }
      { i : ‚Ñï }
      { as : AssocList (AccountId √ó Token) ‚Ñï }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { e : Environment }
      { m : PosixTime }
    --------------------------------------------
    ‚Üí record {
        contract = Close ;
        state = record {
          accounts = ((a , t) , i) ‚à∑ as ;
          choices = cs ;
          boundValues = vs ;
          minTime = m
          } ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = Close ;
        state = record {
          accounts = as ;
          choices = cs ;
          boundValues = vs ;
          minTime = m
          } ;
        environment = e ;
        warnings = ws ;
        payments = mkPayment a (mkAccount a) t i ‚à∑ ps
      }

  PayNonPositive :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a : AccountId }
      { y : Payee }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s ‚Ñ§.‚â§ 0‚Ñ§
    -----------------------------
    ‚Üí record {
        contract = Pay a y t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ReduceNonPositivePay a y t (‚Ñ∞‚ü¶ v ‚üß e s) ‚à∑ ws ;
        payments = ps
      }

  PayNoAccount :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a : AccountId }
      { y : Payee }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s > 0‚Ñ§
    ‚Üí (a , t) ‚àâ accounts s
    -----------------------------
    ‚Üí record {
        contract = Pay a y t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ReducePartialPay a y t 0 ‚à£ ‚Ñ∞‚ü¶ v ‚üß e s ‚à£ ‚à∑ ws ; -- TODO: proper warning?
        payments = ps
      }

  PayInternalTransfer :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a‚Çõ a‚Çú : AccountId }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s > 0‚Ñ§
    ‚Üí (p : (a‚Çõ , t) ‚àà accounts s)
    -----------------------------
    ‚Üí let m = proj‚ÇÇ (lookup p)
          n = ‚à£ ‚Ñ∞‚ü¶ v ‚üß e s ‚à£
      in
      record {
        contract = Pay a‚Çõ (mkAccount a‚Çú) t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s { accounts = ((a‚Çú , t) , (m ‚äì n)) ‚Üë-update (p ‚à∑= (proj‚ÇÅ (lookup p) , m ‚à∏ n)) } ;
        environment = e ;
        warnings = if (m <·µá n) then ReducePartialPay a‚Çõ (mkAccount a‚Çú) t m n ‚à∑ ws else ws ;
        payments = ps
      }

  PayExternal :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a : AccountId }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { p : Party }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s > 0‚Ñ§
    ‚Üí (q : (a , t) ‚àà accounts s)
    -----------------------------
    ‚Üí let m = proj‚ÇÇ (lookup q)
          n = ‚à£ ‚Ñ∞‚ü¶ v ‚üß e s ‚à£
      in
      record {
        contract = Pay a (mkParty p) t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s { accounts = q ‚à∑= (proj‚ÇÅ (lookup q) , m ‚à∏ n) } ;
        environment = e ;
        warnings = if (m <·µá n) then ReducePartialPay a (mkParty p) t m n ‚à∑ ws else ws ;
        payments = mkPayment a (mkParty p) t (m ‚äì n) ‚à∑ ps
      }

  IfTrue :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c‚ÇÅ c‚ÇÇ : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° true
    -----------------------------
    ‚Üí record {
        contract = If o c‚ÇÅ c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c‚ÇÅ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }

  IfFalse :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c‚ÇÅ c‚ÇÇ : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° false
    -----------------------------
    ‚Üí record {
        contract = If o c‚ÇÅ c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }

  WhenTimeout :
    ‚àÄ { s : State }
      { t t‚Çõ Œî‚Çú : ‚Ñï }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { cs : List Case }
    ‚Üí t ‚Ñï.‚â§ t‚Çõ
    -----------------------------
    ‚Üí record {
        contract = When cs (mkTimeout (mkPosixTime t)) c ;
        state = s;
        environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
        warnings = ws ;
        payments = ps
      }

  LetShadow :
    ‚àÄ { s : State }
      { e : Environment }
      { c : Contract }
      { i : ValueId }
      { v : Value }
      { v·µ¢ : Int }
      { ws ws' : List ReduceWarning }
      { ps : List Payment }
    ‚Üí (i , v·µ¢) ‚àà-List boundValues s
    ‚Üí ws' ‚â°  ReduceShadowing i v·µ¢ (‚Ñ∞‚ü¶ v ‚üß e s) ‚à∑ ws
    ----------------------------------------------------
    ‚Üí record {
        contract = Let i v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws' ;
        payments = ps
      }

  LetNoShadow :
    ‚àÄ { s : State }
      { e : Environment }
      { c : Contract }
      { i : ValueId }
      { v : Value }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí i ‚àâ boundValues s
    -----------------------------
    ‚Üí record {
        contract = Let i v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s { boundValues = (i , ‚Ñ∞‚ü¶ v ‚üß e s) ‚à∑ boundValues s } ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }

  AssertTrue :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° true
    -----------------------------
    ‚Üí record {
        contract = Assert o c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }

  AssertFalse :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° false
    -----------------------------
    ‚Üí record {
        contract = Assert o c ;
        state = s ;
        environment = e ;
        warnings = ws;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ReduceAssertionFailed ‚à∑ ws ;
        payments = ps
      }


-- reflexive and transitive closure
infix  2 _‚áÄ‚ãÜ_
infix  1 begin_
infixr 2 _‚áÄ‚ü®_‚ü©_
infix  3 _‚àé

data _‚áÄ‚ãÜ_ : Configuration ‚Üí Configuration ‚Üí Set where
  _‚àé : ‚àÄ M
      ------
    ‚Üí M ‚áÄ‚ãÜ M

  _‚áÄ‚ü®_‚ü©_ : ‚àÄ L {M N}
    ‚Üí L ‚áÄ M
    ‚Üí M ‚áÄ‚ãÜ N
      ------
    ‚Üí L ‚áÄ‚ãÜ N

begin_ : ‚àÄ {M N}
  ‚Üí M ‚áÄ‚ãÜ N
    ------
  ‚Üí M ‚áÄ‚ãÜ N
begin M‚áÄ‚ãÜN = M‚áÄ‚ãÜN

data Quiescent : Configuration ‚Üí Set where

  close :
    ‚àÄ { e : Environment }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { ws : List ReduceWarning }
      { m : PosixTime }
      { ps : List Payment }
    ---------------------------------
    ‚Üí Quiescent record {
          contract = Close ;
          state =
            record
              { accounts = [] ;
                choices = cs ;
                boundValues = vs ;
                minTime = m
              } ;
            environment = e ;
            warnings = ws ;
            payments = ps
        }

  waiting :
    ‚àÄ { t t‚Çõ Œî‚Çú : ‚Ñï }
      { m : PosixTime }
      { cases : List Case }
      { as : AssocList (AccountId √ó Token) ‚Ñï }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí let t‚Çë = t‚Çõ + Œî‚Çú
       in t‚Çë ‚Ñï.< t
    ------------------------------------------
    ‚Üí Quiescent record {
          contract = When cases (mkTimeout (mkPosixTime t)) c ;
          state =
            record
              { accounts = as ;
                choices = cs ;
                boundValues = vs ;
                minTime = m
              } ;
          environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
          warnings = ws ;
          payments = ps
        }

data AmbiguousTimeInterval : Configuration ‚Üí Set where

  AmbiguousTimeIntervalError :
    ‚àÄ {t t‚Çõ Œî‚Çú : ‚Ñï}
      { cs : List Case }
      { c : Contract }
      { s : State }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí t‚Çõ ‚Ñï.< t
    ‚Üí (t‚Çõ + Œî‚Çú) ‚Ñï.‚â• t
    ‚Üí AmbiguousTimeInterval record {
           contract = When cs (mkTimeout (mkPosixTime t)) c ;
           state = s ;
           environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
           warnings = ws ;
           payments = ps
        }

data Reducible (C : Configuration) : Set where

  step : ‚àÄ {D}
    ‚Üí C ‚áÄ D
      -----------
    ‚Üí Reducible C

  quiescent :
      Quiescent C
      -----------
    ‚Üí Reducible C

  ambiguousTimeInterval :
      AmbiguousTimeInterval C
      -----------------------
    ‚Üí Reducible C


progress : ‚àÄ (C : Configuration) ‚Üí Reducible C
progress record
  { contract = Close
  ; state = record
    { accounts = [] ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = _
  ; warnings = _
  ; payments = _
  } = quiescent close
progress record
  { contract = Close
  ; state = record
    { accounts = a ‚à∑ as ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = _
  ; warnings = _
  ; payments = _
  } = step CloseRefund
progress record
  { contract = Pay a (mkAccount p) t v c
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ‚Ñ∞‚ü¶ v ‚üß e s ‚â§? 0‚Ñ§ | (a , t) ‚àà?-AccountId√óToken (accounts s)
... | yes q | _ = step (PayNonPositive q)
... | no ¬¨p | yes q = step (PayInternalTransfer (‚Ñ§.‚â∞‚áí> ¬¨p) q)
... | no ¬¨p | no ¬¨q = step (PayNoAccount (‚Ñ§.‚â∞‚áí> ¬¨p) (¬¨Any‚áíAll¬¨ (accounts s) ¬¨q))
progress record
  { contract = Pay a (mkParty p) t v c
  ; state = s
  ; environment = e
  ; warnings = ws
  ; payments = ps
  } with ‚Ñ∞‚ü¶ v ‚üß e s ‚â§? 0‚Ñ§ | (a , t) ‚àà?-AccountId√óToken (accounts s)
... | yes q | _ = step (PayNonPositive q)
... | no ¬¨p | yes q = step (PayExternal (‚Ñ§.‚â∞‚áí> ¬¨p) q)
... | no ¬¨p | no ¬¨q = step (PayNoAccount (‚Ñ§.‚â∞‚áí> ¬¨p) (¬¨Any‚áíAll¬¨ (accounts s) ¬¨q))
progress record
  { contract = If o c‚ÇÅ c‚ÇÇ
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ùí™‚ü¶ o ‚üß e s ‚âü true
... | yes p = step (IfTrue p)
... | no ¬¨p = step (IfFalse (¬¨-not ¬¨p))
progress record
  { contract = When cs (mkTimeout (mkPosixTime t)) c
  ; state = record
    { accounts = _ ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú)
  ; warnings = _
  ; payments = _
  } with (t‚Çõ + Œî‚Çú) ‚Ñï.<? t | t ‚Ñï.‚â§? t‚Çõ
... | yes p | _ = quiescent (waiting p)
... | _ | yes q = step (WhenTimeout q)
... | no ¬¨p | no ¬¨q = ambiguousTimeInterval (AmbiguousTimeIntervalError (‚â∞‚áí> ¬¨q) (‚âÆ‚áí‚â• ¬¨p))
progress record
  { contract = Let i v c
  ; state = s@(record
    { accounts = _ ;
      choices = _ ;
      boundValues = vs ;
      minTime = _
    })
  ; environment = e
  ; warnings = ws
  ; payments = ps
  } with i ‚àà-ValueId? vs
... | yes p =
  let v·µ¢ = proj‚ÇÇ (lookup p)
  in step (LetShadow {s} {e} {c} {i} {v} {v·µ¢} {ws} {ReduceShadowing i v·µ¢ (‚Ñ∞‚ü¶ v ‚üß e s) ‚à∑ ws} {ps} (lookup‚àà-L p) refl)
  where
    lookup‚àà-L : ‚àÄ {A B : Set} {a : A} {abs : AssocList A B} ‚Üí (p : a ‚àà abs) ‚Üí (a , proj‚ÇÇ (lookup p)) ‚àà-List abs
    lookup‚àà-L (here refl) = here refl
    lookup‚àà-L (there p) = there (lookup‚àà-L p)
... | no ¬¨p = step (LetNoShadow (¬¨Any‚áíAll¬¨ vs ¬¨p))
progress record
  { contract = Assert o c
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ùí™‚ü¶ o ‚üß e s ‚âü true
... | yes p = step (AssertTrue p)
... | no ¬¨p = step (AssertFalse (¬¨-not ¬¨p))

data FinishedEvaluation (C : Configuration) : Set where

  steps : ‚àÄ {D}
    ‚Üí C ‚áÄ‚ãÜ D
    ‚Üí FinishedEvaluation C

  ambiguousTimeInterval :
    FinishedEvaluation C

  done :
    FinishedEvaluation C

-- Evaluator
eval : ‚àÄ (C : Configuration) ‚Üí ‚Ñï ‚Üí FinishedEvaluation C
eval C zero = steps (C ‚àé)
eval C (suc m) with progress C
... | quiescent _ = steps (C ‚àé)
... | ambiguousTimeInterval _ = ambiguousTimeInterval
... | step {D} C‚áÄD with eval D m
...      | steps D‚áÄ‚ãÜE = steps ( C ‚áÄ‚ü® C‚áÄD ‚ü© D‚áÄ‚ãÜE )
...      | _ = done


-- Examples

role‚ÇÅ role‚ÇÇ : Party
role‚ÇÅ = Role (mkByteString "foo")
role‚ÇÇ = Role (mkByteString "bar")

accountId‚ÇÅ accountId‚ÇÇ : AccountId
accountId‚ÇÅ = mkAccountId role‚ÇÅ
accountId‚ÇÇ = mkAccountId role‚ÇÇ

token‚ÇÅ : Token
token‚ÇÅ = mkToken (mkByteString "") (mkByteString "")

config‚ÇÄ : Configuration
config‚ÇÄ = record
  { contract = If TrueObs Close Close
  ; state = record
    { accounts = [ (accountId‚ÇÅ , token‚ÇÅ ) , 5 ]
    ; choices = []
    ; boundValues = []
    ; minTime = mkPosixTime 0
    }
  ; environment = mkEnvironment (mkInterval (mkPosixTime 0) 5)
  ; warnings = []
  ; payments = []
  }

config‚ÇÅ : Configuration
config‚ÇÅ = record
  { contract = Close
  ; state = record
    { accounts = [ ( accountId‚ÇÅ , token‚ÇÅ ) , 5 ]
    ; choices = []
    ; boundValues = []
    ; minTime = mkPosixTime 0
    }
  ; environment = mkEnvironment (mkInterval (mkPosixTime 0) 5)
  ; warnings = []
  ; payments = []
  }

config‚ÇÇ : Configuration
config‚ÇÇ = record
  { contract = Close
  ; state = record
    { accounts = []
    ; choices = []
    ; boundValues = []
    ; minTime = mkPosixTime 0
    }
  ; environment = mkEnvironment (mkInterval (mkPosixTime 0) 5)
  ; warnings = []
  ; payments = [ mkPayment accountId‚ÇÅ (mkAccount accountId‚ÇÅ) token‚ÇÅ 5 ]
  }

_ = eval config‚ÇÄ 100 ‚â° steps (config‚ÇÄ ‚áÄ‚ü® IfTrue refl ‚ü© config‚ÇÅ ‚áÄ‚ü® CloseRefund ‚ü© config‚ÇÇ ‚àé)
