
module Marlowe.Semantics.Reduce where


open import Agda.Builtin.Int using (Int)
open import Data.Bool using (Bool; if_then_else_; not; _‚àß_; _‚à®_; true; false)
open import Data.Bool.Properties as ùîπ using ()
open import Data.Integer using (_<?_; _‚â§?_; _‚âü_ ; _‚äî_; _‚äì_; _+_; _-_; 0‚Ñ§ ; _‚â§_ ; _>_ ; _‚â•_ ; _<_; ‚à£_‚à£; +_)
open import Data.Integer.Properties as ‚Ñ§ using ()
open import Data.List using (List; []; _‚à∑_; _++_; foldr; reverse; [_]; null)
open import Data.List.Relation.Unary.Any using (satisfied; lookup)
open import Data.List.Relation.Unary.All.Properties using (¬¨Any‚áíAll¬¨)
open import Data.Maybe using (Maybe; just; nothing; fromMaybe)
open import Data.Nat as ‚Ñï using (‚Ñï; suc; s‚â§s)
open import Data.Nat.Properties as ‚Ñï using (1+n‚â∞n; ‚â§-trans)
open import Data.Product using (Œ£; _,_; ‚àÉ; Œ£-syntax; ‚àÉ-syntax)
open import Data.Product using (_√ó_; proj‚ÇÅ; proj‚ÇÇ)
import Data.String as String
open import Function.Base using (case_of_)
open import Marlowe.Language.Contract
open import Marlowe.Language.Input
open import Marlowe.Language.State
open import Marlowe.Language.Transaction
open import Marlowe.Semantics.Evaluate
open import Marlowe.Semantics.Operate using (
  ReduceWarning;
  ReduceNoWarning;
  ReduceNonPositivePay;
  ReducePartialPay;
  ReduceShadowing;
  ReduceAssertionFailed
  )
open import Primitives
open import Relation.Nullary.Decidable using (‚åä_‚åã)
open import Relation.Nullary using (Dec; yes; no; ¬¨_)

open import Data.List.Membership.Propositional using () renaming (_‚àà_ to _‚ãµ_)

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_‚â°_; refl; cong; sym)
open import Data.Empty using (‚ä•; ‚ä•-elim)

open import Primitives
open Decidable _eqAccountIdTokenDec_  renaming (_‚Äº_default_ to _‚Äº·µÉ_default_) hiding (_‚àà?_)
open Decidable _eqChoiceId_ renaming (_‚Äº_default_ to _‚Äº·∂ú_default_) using (_‚àà?_)
open Decidable _eqValueId_ renaming (_‚Äº_ to _‚Äº·µõ_; _‚Äº_default_ to _‚Äº·µõ_default_; _‚àà?_ to _‚àà·µõ?_; isElem to isElem·µõ)

open Environment using (timeInterval)
open State using (accounts; boundValues; choices)
open TimeInterval using (startTime)

record Configuration : Set where
  field contract : Contract
        state : State
        environment : Environment
        warnings : List ReduceWarning
        payments : List Payment

open Configuration

data _‚áÄ_ : Configuration ‚Üí Configuration ‚Üí Set where

  {-
  CloseRefund :
    ‚àÄ { c : Configuration } { a : AccountId } { t : Token } { i : ‚Ñï } { as : AssocList (AccountId √ó Token) ‚Ñï }
    ‚Üí (accounts (state c)) ‚â° (( a , t ) , i) ‚à∑ as
    ‚Üí (contract c) ‚â° Close
    ‚Üí c ‚áÄ record c { state = record (state c) { accounts = as }}
  -}

  CloseRefund :
    ‚àÄ { e : Environment }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { as : AssocList (AccountId √ó Token) ‚Ñï }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { m : PosixTime }
      { a : AccountId }
      { t : Token }
      { i : ‚Ñï }
    --------------------------------------------
    ‚Üí record {
        contract = Close ;
        state = record {
          accounts = ((a , t) , i) ‚à∑ as ;
          choices = cs ;
          boundValues = vs ;
          minTime = m
          } ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = Close ;
        state = record {
          accounts = as ;
          choices = cs ;
          boundValues = vs ;
          minTime = m
          } ;
        environment = e ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps ++ [ mkPayment a (mkAccount a) t i ]
      }

  PayNonPositive :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a : AccountId }
      { y : Payee }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s ‚â§ 0‚Ñ§
    -----------------------------
    ‚Üí record {
        contract = Pay a y t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws ++ [ ReduceNonPositivePay a y t (‚Ñ∞‚ü¶ v ‚üß e s) ] ;
        payments = ps
      }

  PayInternalTransfer :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a‚Çõ a‚Çú : AccountId }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s > 0‚Ñ§
    -----------------------------
    ‚Üí let n = ‚à£ ‚Ñ∞‚ü¶ v ‚üß e s ‚à£
          s‚Çõ = (a‚Çõ , t) ‚Äº·µÉ accounts s default 0
          s‚Çú = (a‚Çú , t) ‚Äº·µÉ accounts s default 0
      in
      record {
        contract = Pay a‚Çõ (mkAccount a‚Çú) t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s
          { accounts = ((a‚Çú , t) , (s‚Çú ‚Ñï.+ n)) ‚Üë (((a‚Çõ , t) , (s‚Çõ ‚Ñï.‚à∏ n)) ‚Üë accounts s) } ;
        environment = e ;
        warnings = ws ++ [ if (s‚Çõ ‚Ñï.<·µá n)
            then ReducePartialPay a‚Çõ (mkAccount a‚Çú) t s‚Çõ n
            else ReduceNoWarning
          ];
        payments = ps
      }

  PayExternal :
    ‚àÄ { s : State }
      { e : Environment }
      { v : Value }
      { a‚Çì : AccountId }
      { t : Token }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { p : Party }
    ‚Üí ‚Ñ∞‚ü¶ v ‚üß e s > 0‚Ñ§
    -----------------------------
    ‚Üí let n = ‚à£ ‚Ñ∞‚ü¶ v ‚üß e s ‚à£
          s‚Çì = (a‚Çì , t) ‚Äº·µÉ accounts s default 0
      in
      record {
        contract = Pay a‚Çì (mkParty p) t v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s
          { accounts = ((a‚Çì , t) , (s‚Çì ‚Ñï.‚à∏ n)) ‚Üë accounts s } ;
        environment = e ;
        warnings = ws ++ [ if (s‚Çì ‚Ñï.<·µá n)
            then ReducePartialPay a‚Çì (mkParty p) t s‚Çì n
            else ReduceNoWarning
          ] ;
        payments = ps ++ [ mkPayment a‚Çì (mkParty p) t (s‚Çì ‚Ñï.‚äì n) ]
      }

  IfTrue :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c‚ÇÅ c‚ÇÇ : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° true
    -----------------------------
    ‚Üí record {
        contract = If o c‚ÇÅ c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c‚ÇÅ ;
        state = s ;
        environment = e ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps
      }

  IfFalse :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c‚ÇÅ c‚ÇÇ : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° false
    -----------------------------
    ‚Üí record {
        contract = If o c‚ÇÅ c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c‚ÇÇ ;
        state = s ;
        environment = e ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps
      }

  WhenTimeout :
    ‚àÄ { s : State }
      { t t‚Çõ Œî‚Çú : ‚Ñï }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
      { cs : List Case }
    ‚Üí t ‚Ñï.‚â§ t‚Çõ
    -----------------------------
    ‚Üí record {
        contract = When cs (mkTimeout (mkPosixTime t)) c ;
        state = s;
        environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps
      }

  LetShadow :
    ‚àÄ { s : State }
      { e : Environment }
      { c : Contract }
      { i : ValueId }
      { v : Value }
      { v·µ¢ : Int }
      { ws ws' : List ReduceWarning }
      { ps : List Payment }
    ‚Üí just v·µ¢ ‚â° i ‚Äº·µõ boundValues s
    ‚Üí ws' ‚â°  ws ++ [ ReduceShadowing i v·µ¢ (‚Ñ∞‚ü¶ v ‚üß e s) ]
    ----------------------------------------------------
    ‚Üí record {
        contract = Let i v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws' ;
        payments = ps
      }

  LetNoShadow :
    ‚àÄ { s : State }
      { e : Environment }
      { c : Contract }
      { i : ValueId }
      { v : Value }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí i ‚àâ boundValues s
    -----------------------------
    ‚Üí record {
        contract = Let i v c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = record s { boundValues = (i , ‚Ñ∞‚ü¶ v ‚üß e s) ‚Üë boundValues s } ;
        environment = e ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps
      }

  AssertTrue :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° true
    -----------------------------
    ‚Üí record {
        contract = Assert o c ;
        state = s ;
        environment = e ;
        warnings = ws ;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws ++ [ ReduceNoWarning ] ;
        payments = ps
      }

  AssertFalse :
    ‚àÄ { s : State }
      { e : Environment }
      { o : Observation }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí ùí™‚ü¶ o ‚üß e s ‚â° false
    -----------------------------
    ‚Üí record {
        contract = Assert o c ;
        state = s ;
        environment = e ;
        warnings = ws;
        payments = ps
      }
      ‚áÄ
      record {
        contract = c ;
        state = s ;
        environment = e ;
        warnings = ws ++ [ ReduceAssertionFailed ] ;
        payments = ps
      }


-- reflexive and transitive closure

infix  2 _‚áÄ‚ãÜ_
infix  1 begin_
infixr 2 _‚áÄ‚ü®_‚ü©_
infix  3 _‚àé

data _‚áÄ‚ãÜ_ : Configuration ‚Üí Configuration ‚Üí Set where
  _‚àé : ‚àÄ M
      ------
    ‚Üí M ‚áÄ‚ãÜ M

  _‚áÄ‚ü®_‚ü©_ : ‚àÄ L {M N}
    ‚Üí L ‚áÄ M
    ‚Üí M ‚áÄ‚ãÜ N
      ------
    ‚Üí L ‚áÄ‚ãÜ N

begin_ : ‚àÄ {M N}
  ‚Üí M ‚áÄ‚ãÜ N
    ------
  ‚Üí M ‚áÄ‚ãÜ N
begin M‚áÄ‚ãÜN = M‚áÄ‚ãÜN


data Quiescent : Configuration ‚Üí Set where

  close :
    ‚àÄ { e : Environment }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { ws : List ReduceWarning }
      { m : PosixTime }
      { ps : List Payment }
    ---------------------------------
    ‚Üí Quiescent record {
          contract = Close ;
          state =
            record
              { accounts = [] ;
                choices = cs ;
                boundValues = vs ;
                minTime = m
              } ;
            environment = e ;
            warnings = ws ;
            payments = ps
        }

  waiting :
    ‚àÄ { t t‚Çõ Œî‚Çú : ‚Ñï }
      { m : PosixTime }
      { cases : List Case }
      { as : AssocList (AccountId √ó Token) ‚Ñï }
      { cs : AssocList ChoiceId Int }
      { vs : AssocList ValueId Int }
      { c : Contract }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí let t‚Çë = t‚Çõ ‚Ñï.+ Œî‚Çú
       in t‚Çë ‚Ñï.< t
    ------------------------------------------
    ‚Üí Quiescent record {
          contract = When cases (mkTimeout (mkPosixTime t)) c ;
          state =
            record
              { accounts = as ;
                choices = cs ;
                boundValues = vs ;
                minTime = m
              } ;
            environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
            warnings = ws ;
            payments = ps
        }

-- Quiescent configurations do not reduce
Quiescent¬¨‚áÄ :
  ‚àÄ { C‚ÇÅ C‚ÇÇ : Configuration }
  ‚Üí Quiescent C‚ÇÅ
  ---------------------------
  ‚Üí ¬¨ (C‚ÇÅ ‚áÄ C‚ÇÇ)
Quiescent¬¨‚áÄ close ()
Quiescent¬¨‚áÄ (waiting {t} {t‚Çõ} {Œî‚Çú} (x)) (WhenTimeout {_} {t} {t‚Çõ} {Œî‚Çú} y) =
  let ¬¨p = ‚Ñï.‚â§‚áí‚âØ (‚Ñï.‚â§-trans y (‚Ñï.m‚â§m+n t‚Çõ Œî‚Çú)) in ¬¨p x

-- If a configuration reduces, it is not quiescent
‚áÄ¬¨Quiescent :
  ‚àÄ { C‚ÇÅ C‚ÇÇ : Configuration }
  ‚Üí C‚ÇÅ ‚áÄ C‚ÇÇ
  ‚Üí ¬¨ Quiescent C‚ÇÅ
‚áÄ¬¨Quiescent C‚ÇÅ‚áÄC‚ÇÇ q = Quiescent¬¨‚áÄ q C‚ÇÅ‚áÄC‚ÇÇ


data AmbiguousTimeInterval : Configuration ‚Üí Set where

  AmbiguousTimeIntervalError :
    ‚àÄ {t t‚Çõ Œî‚Çú : ‚Ñï}
      { cs : List Case }
      { c : Contract }
      { s : State }
      { ws : List ReduceWarning }
      { ps : List Payment }
    ‚Üí t‚Çõ ‚Ñï.< t
    ‚Üí (t‚Çõ ‚Ñï.+ Œî‚Çú) ‚Ñï.‚â• t
    ‚Üí AmbiguousTimeInterval record {
           contract = When cs (mkTimeout (mkPosixTime t)) c ;
           state = s ;
           environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú) ;
           warnings = ws ;
           payments = ps
        }


data Reduce (C : Configuration) : Set where

  reduce : ‚àÄ {D}
    ‚Üí C ‚áÄ D
      --------
    ‚Üí Reduce C

  done :
      Quiescent C
      -----------
    ‚Üí Reduce C

  error :
      AmbiguousTimeInterval C
      -----------------------
    ‚Üí Reduce C


progress : ‚àÄ (C : Configuration) ‚Üí Reduce C
progress record
  { contract = Close
  ; state = record
    { accounts = [] ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = _
  ; warnings = _
  ; payments = _
  } = done close
progress record
  { contract = Close
  ; state = record
    { accounts = a ‚à∑ as ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = _
  ; warnings = _
  ; payments = _
  } = reduce CloseRefund
progress record
  { contract = Pay a (mkAccount p) t v c
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ‚Ñ∞‚ü¶ v ‚üß e s ‚â§? 0‚Ñ§
... | yes q = let t = PayNonPositive q in reduce t
... | no ¬¨p = let t = PayInternalTransfer (‚Ñ§.‚â∞‚áí> ¬¨p) in reduce t
progress record
  { contract = Pay a (mkParty p) t v c
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ‚Ñ∞‚ü¶ v ‚üß e s ‚â§? 0‚Ñ§
... | yes q = let t = PayNonPositive q in reduce t
... | no ¬¨p = let t = PayExternal (‚Ñ§.‚â∞‚áí> ¬¨p) in reduce t
progress record
  { contract = If o c‚ÇÅ c‚ÇÇ
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ùí™‚ü¶ o ‚üß e s ùîπ.‚âü true
... | yes p = let t = IfTrue p in reduce t
... | no ¬¨p = let t = IfFalse (ùîπ.¬¨-not ¬¨p) in reduce t
progress record
  { contract = When cs (mkTimeout (mkPosixTime t)) c
  ; state = record
    { accounts = _ ;
      choices = _ ;
      boundValues = _ ;
      minTime = _
    }
  ; environment = mkEnvironment (mkInterval (mkPosixTime t‚Çõ) Œî‚Çú)
  ; warnings = _
  ; payments = _
  } with (t‚Çõ ‚Ñï.+ Œî‚Çú) ‚Ñï.<? t | t ‚Ñï.‚â§? t‚Çõ
... | yes p | _ = done (waiting p)
... | _ | yes q = reduce (WhenTimeout q)
... | no ¬¨p | no ¬¨q = error (AmbiguousTimeIntervalError (‚Ñï.‚â∞‚áí> ¬¨q) (‚Ñï.‚âÆ‚áí‚â• ¬¨p))
progress record
  { contract = Let i v c
  ; state = s@(record
    { accounts = _ ;
      choices = _ ;
      boundValues = vs ;
      minTime = _
    })
  ; environment = e
  ; warnings = ws
  ; payments = ps
  } with i ‚àà·µõ? vs
... | yes p =
         let ( _ , v‚Çì ) = lookup p
             t = LetShadow {s} {e} {c} {i} {v} {v‚Çì} {ws} {ws ++ [ ReduceShadowing i v‚Çì (‚Ñ∞‚ü¶ v ‚üß e s) ]} {ps} (isElem·µõ p) refl
           in reduce t
... | no ¬¨p = let t = LetNoShadow (¬¨Any‚áíAll¬¨ vs ¬¨p) in reduce t
progress record
  { contract = Assert o c
  ; state = s
  ; environment = e
  ; warnings = _
  ; payments = _
  } with ùí™‚ü¶ o ‚üß e s ùîπ.‚âü true
... | yes p = let t = AssertTrue p in reduce t
... | no ¬¨p = let t = AssertFalse (ùîπ.¬¨-not ¬¨p) in reduce t
